<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#39ff14">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>EarAssist — Audio Assist + Optional Live Captions</title>
  <style>
    :root { --bg:#0f1115; --fg:#e6edf3; --accent:#39ff14; --muted:#8aa3b0; --panel:#171a21; --line:#ffffff; --good:#1ee0a2; --warn:#ffb300; --bad:#ff5a5f; }
    [data-theme="light"]{ --bg:#f0f2f5; --fg:#1e2328; --accent:#007b7f; --muted:#545f69; --panel:#ffffff; --line:#000000; --good:#0fad82; --warn:#f59e0b; --bad:#ef4444; }
    [data-theme="solar"]{ --bg:#bfa873; --fg:#fdf6e3; --accent:#b58900; --muted:#6c7a80; --panel:#8c7a50; --line:#fce48c; --good:#2aa198; --warn:#cb4b16; --bad:#dc322f; }
    [data-theme="ocean"]{ --bg:#003344; --fg:#d6deeb; --accent:#2bbac5; --muted:#9fb3c8; --panel:#005577; --line:#007799; --good:#22d3ee; --warn:#eab308; --bad:#fb7185; }
    [data-theme="orange"]{ --bg:#402000; --fg:#fff0e0; --accent:#ff8a00; --muted:#ffd166; --panel:#663300; --line:#ffd166; --good:#ffd166; --warn:#ffa600; --bad:#ef476f; }
    * { box-sizing: border-box; }
    html { overflow-x:hidden; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background:var(--bg); color:var(--fg); overflow-x:hidden;  overflow-x:hidden; }
    header.hdr{
      display:flex;
      flex-direction:column;
      gap:10px;
      align-items:center;
      justify-content:center;
      padding:14px 16px 12px;
      border-bottom:1px solid var(--line);
      background:var(--panel);
      position:relative;
      z-index:10;
    }
    
    /* ===== EarAssist 3-row balanced header ===== */
    .hdrTitle{ text-align:center; line-height:1.05; }
    .brand{
      font-size:22px;
      font-weight:850;
      letter-spacing:.6px;
      display:inline-block;
      padding-bottom:6px;
      position:relative;
      text-transform:none;
      text-shadow: 0 0 14px rgba(57,255,20,.18);
    }
    .brand::after{
      content:"";
      position:absolute;
      left:10%;
      right:10%;
      bottom:0;
      height:2px;
      border-radius:999px;
      background:linear-gradient(90deg, transparent, var(--accent), transparent);
      box-shadow: 0 0 10px rgba(57,255,20,.25);
    }
    .tagline{ font-size:13px; opacity:.88; margin-top:6px; }
    .dotSep{ opacity:.6; padding:0 6px; }

    .hdrRow{ width:100%; max-width:1100px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; }
    .hdrLabel{ font-size:13px; opacity:.95; display:flex; align-items:center; gap:8px; }
    .hdrLabel select{ min-width:240px; }

    .hdrBtns{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .hdrMeta{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }

    /* Slightly smaller header buttons (mic/output stay readable) */
    header.hdr button{ padding:7px 12px; border-radius:12px; font-size:13px; }
    header.hdr .primary{ font-weight:800; }

    @media (max-width:520px){
      .hdrLabel select{ min-width: min(92vw, 360px); }
      header.hdr{ padding:14px 12px 12px; }
      header.hdr button{ padding:7px 10px; }
    }
h1 { margin:0; font-size:18px; letter-spacing:.3px; font-weight:700; }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; }
    select, button, input[type="range"] {
      width: auto; background:#0d121a; color:var(--fg); border:1px solid var(--line); padding:10px 12px; border-radius:12px; font-size:15px; min-height:44px; }
    [data-theme="light"] select, [data-theme="light"] button, [data-theme="light"] input[type="range"] { background:#fff; }
    button { cursor:pointer; border:1px solid var(--line); background:var(--panel); transition:transform .05s ease, background .2s ease, border-color .2s ease; }
    button:hover { border-color:var(--accent); }
    button:active { transform:translateY(1px); }
    .primary { background:var(--accent); color:#001013; border-color:transparent; }
    main { max-width:1100px; margin:18px auto; padding:0 16px 24px; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(12, 1fr); }
    .card { grid-column: span 12; background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px 14px; box-shadow: 0 6px 14px rgba(0,0,0,.18); }
    .card h3 { margin:4px 0 10px; font-size:14px; opacity:.9; letter-spacing:.3px; }
    .k { background:#0b1320; border:1px solid var(--line); padding:10px 12px; border-radius:10px; display:inline-flex; gap:8px; align-items:center; }
    label { font-size:13px; opacity:.95; }
    .small { font-size:12px; opacity:.7; }
    .pill { padding:8px 12px; border-radius:999px; border:1px solid var(--line); background:transparent; }
    .bars { display:flex; flex-wrap:wrap; align-items:center; gap:10px; }
    .bars .g { flex:1; min-width:260px; }
    .split { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:900px){ .split{ grid-template-columns:1fr; } }
    @media (max-width:600px){
      header .row{ width:100%; }
      header label{ flex:1 1 48%; min-width:160px; }
      header button{ flex:1 1 30%; }
      header .pill.small{ flex:1 1 45%; }
    }

    input[type="range"]{ width:100%; }
    canvas { width:100%; height:220px; background:#0a0f18; border-radius:12px; border:1px solid var(--line); }
    input[type=range]{ width:100%; }


    /* Range styling */
    input[type=range]::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width:20px; height:20px; border-radius:50%; background:var(--accent); border:2px solid #fff; box-shadow:0 2px 5px rgba(0,0,0,0.6), inset 0 2px 3px rgba(255,255,255,0.4); cursor:pointer; margin-top:-6px; }
    input[type=range]::-moz-range-thumb { width:20px; height:20px; border-radius:50%; background:var(--accent); border:2px solid #fff; box-shadow:0 2px 5px rgba(0,0,0,0.6), inset 0 2px 3px rgba(255,255,255,0.4); cursor:pointer; }
    input[type=range]::-webkit-slider-runnable-track { height:8px; border-radius:8px; background:linear-gradient(90deg, var(--accent) 0%, var(--muted) 50%, var(--accent) 100%); box-shadow: inset 0 2px 4px rgba(0,0,0,0.4); }
    input[type=range]::-moz-range-track { height:8px; border-radius:8px; background:linear-gradient(90deg, var(--accent) 0%, var(--muted) 50%, var(--accent) 100%); box-shadow: inset 0 2px 4px rgba(0,0,0,0.4); }
    input[type=range]:hover::-webkit-slider-thumb, input[type=range]:active::-webkit-slider-thumb, input[type=range]:hover::-moz-range-thumb, input[type=range]:active::-moz-range-thumb { box-shadow:0 0 10px var(--accent), 0 2px 5px rgba(0,0,0,0.6); }

    /* Toggle polish */
    .k input[type=checkbox] { -webkit-appearance:none; appearance:none; width:38px; height:20px; border-radius:20px; border:2px solid var(--line); background:var(--muted); position:relative; outline:none; cursor:pointer; transition:background .3s, border-color .3s; }
    .k input[type=checkbox]::before { content:""; position:absolute; top:2px; left:2px; width:14px; height:14px; border-radius:50%; background:#fff; transition:transform .3s; box-shadow:0 1px 3px rgba(0,0,0,0.5); }
    .k input[type=checkbox]:checked { background:var(--accent); border-color:var(--accent); }
    .k input[type=checkbox]:checked::before { transform:translateX(18px); }

    .preset.is-active{ background:var(--accent); color:#000; border-color:var(--accent); box-shadow:0 0 10px rgba(0,0,0,.35); }
    .preset:focus-visible{ outline: 2px solid var(--accent); outline-offset: 2px; }
    :focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px; }

    /* Caption panel */
    .captionBox{
      min-height: 140px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,0.18);
      padding: 14px;
      line-height: 1.35;
      font-size: 22px;
      letter-spacing: .2px;
      overflow: auto;
      white-space: pre-wrap;
    }
    [data-theme="light"] .captionBox{ background: rgba(0,0,0,0.04); }
    .captionLive{ opacity: 1; }
    .captionDim{ opacity: .65; }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px; border-radius:999px; border:1px solid var(--line);
      font-size:12px; opacity:.9;
    }
    .dot{ width:8px; height:8px; border-radius:99px; background:var(--bad); display:inline-block; }
    .dot.on{ background: var(--good); }
  </style>
</head>
<body>
  <header class="hdr">
    <div class="hdrTitle">
      <div class="brand" aria-label="EarAssist">EarAssist</div>
      <div class="tagline">Audio Assist <span class="dotSep">•</span> Optional Live Captions</div>
    </div>

    <div class="hdrRow hdrRow2">
      <label class="hdrLabel">Microphone <select id="micSelect"></select></label>
      <label class="hdrLabel">Output <select id="outSelect"></select></label>
    </div>

    <div class="hdrRow hdrRow3">
      <label class="hdrLabel">Theme
        <select id="themeSelect">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="solar">Solar</option>
          <option value="ocean">Ocean</option>
          <option value="orange">Orange</option>
        </select>
      </label>

      <div class="hdrBtns" role="group" aria-label="Controls">
        <button id="startBtn" class="primary">Start</button>
        <button id="stopBtn">Stop</button>
        <button id="muteBtn">Mute</button>
      </div>

      <div class="hdrMeta" aria-label="Status">
        <span class="pill small">Latency: <span id="latencyVal">--</span> ms</span>
        <span class="pill small">Gate: <span id="gateState">--</span></span>
      </div>
    </div>
  </header>

  <main class="grid">
    <div class="card">
      <h3>Presets</h3>
      <div class="row">
        <button class="pill preset" data-type="assist" aria-label="Speech-focused medical assist">Assist (Medical)</button>
        <button class="pill preset" data-type="speech">Speech Clear</button>
        <button class="pill preset" data-type="noise">Noise Cut</button>
        <button class="pill preset" data-type="natural">Natural</button>
      </div>
      <div class="small">Assist (Medical) prioritizes stable clarity and reduces on/off “chatter.”</div>
    </div>

    <div class="card">
      <h3>EQ</h3>
      <div class="bars">
        <div class="g"><label>Gain <span id="gainVal">1.00</span>x</label><input id="gainCtrl" type="range" min="0.2" max="2.5" step="0.01" value="1.00"></div>
        <div class="g"><label>High-pass <span id="hpVal">150</span> Hz</label><input id="hpCtrl" type="range" min="20" max="1000" step="10" value="150"></div>
        <div class="g"><label>Low-pass <span id="lpVal">6000</span> Hz</label><input id="lpCtrl" type="range" min="1000" max="12000" step="100" value="6000"></div>
      </div>
    </div>

    <div class="card">
      <h3>Filters</h3>
      <div class="row">
        <label class="k"><input id="presenceToggle" type="checkbox"> Presence Boost</label>
        <label class="k"><input id="gateToggle" type="checkbox" checked> Smart Gate</label>
        <label class="k"><input id="notchToggle" type="checkbox"> Notch 60Hz</label>
      </div>
      <div class="small">Smart Gate uses hysteresis + hold-time and a “soft floor” (reduces noise instead of going dead silent).</div>
    </div>

    <div class="card" id="dspControls">
      <h3>Assist Controls</h3>
      <div class="row">
        <button id="nrCalBtn" aria-label="Measure current room noise for the Smart Gate">Calibrate Noise</button>
        <label class="k"><input id="agcToggle" type="checkbox" checked> Medical AGC</label>
        <label class="k"><input id="limiterToggle" type="checkbox" checked> Limiter</label>
        <button id="emergencyBtn" class="pill" aria-label="One-tap clarity boost">Emergency Boost</button>
        <button id="savePresetBtn">Save Preset</button>
        <button id="loadPresetBtn">Load Preset</button>
      </div>
      <div class="small">Tip: run Calibrate Noise in a quiet moment.</div>
    </div>

    <div class="card">
      <h3>Live Captions (Optional)</h3>
      <div class="row">
        <label class="k"><input id="captionsToggle" type="checkbox"> Live Captions</label>
        <label>Language
          <select id="captionLang">
            <option value="en-US">English (US)</option>
            <option value="en-CA" selected>English (Canada)</option>
            <option value="en-GB">English (UK)</option>
            <option value="fr-CA">French (Canada)</option>
            <option value="es-US">Spanish (US)</option>
          </select>
        </label>
        <label>Text Size
          <select id="captionSize">
            <option value="18">Small</option>
            <option value="22" selected>Medium</option>
            <option value="28">Large</option>
            <option value="34">XL</option>
          </select>
        </label>
        <button id="captionClearBtn" class="pill">Clear</button>
        <span class="badge"><span id="capDot" class="dot"></span> <span id="capStatus">Off</span></span>
      </div>
      <div class="small">Captions use the <b>raw microphone</b> (separate from audio processing) for best recognition accuracy. Works best in Chrome.</div>
      <div id="captionPanel" style="margin-top:10px; display:none;">
        <div class="captionBox" id="captionBox">
          <span class="captionDim">Captions are ready. Toggle “Live Captions” to start.</span>
        </div>
      </div>
    </div>

    <div class="card split">
      <div><h3>Visualizer</h3><canvas id="visualizer"></canvas></div>
      <div><h3>Display</h3>
        <label>Mode
          <select id="vizMode">
            <option value="spectrum">Spectrum</option>
            <option value="wave">Waveform</option>
            <option value="split" selected>Split</option>
          </select>
        </label>
        <div class="small" style="margin-top:10px;">
          If you use Bluetooth and notice echo, prefer low-latency devices when possible.
        </div>
      </div>
    </div>
  </main>

  <audio id="audioOut" autoplay style="display:none"></audio>

<script>
(async function(){
  // === Elements ===
  const themeSelect = document.getElementById('themeSelect');
  const micSelect = document.getElementById('micSelect');
  const outSelect = document.getElementById('outSelect');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const muteBtn = document.getElementById('muteBtn');

  const gainCtrl = document.getElementById('gainCtrl');
  const hpCtrl = document.getElementById('hpCtrl');
  const lpCtrl = document.getElementById('lpCtrl');
  const gainVal = document.getElementById('gainVal');
  const hpVal = document.getElementById('hpVal');
  const lpVal = document.getElementById('lpVal');

  const notchToggle = document.getElementById('notchToggle');
  const gateToggle = document.getElementById('gateToggle');
  const presenceToggle = document.getElementById('presenceToggle');

  const presets = document.querySelectorAll('.preset');
  function markActivePreset(btn){
    document.querySelectorAll('.preset').forEach(b=>b.classList.remove('is-active'));
    btn.classList.add('is-active');
  }

  const vizMode = document.getElementById('vizMode');
  const latencyVal = document.getElementById('latencyVal');
  const gateState = document.getElementById('gateState');
  const canvas = document.getElementById('visualizer');
  const ctx = canvas.getContext('2d');
  const audioOut = document.getElementById('audioOut');

  // Assist controls
  const nrCalBtn = document.getElementById('nrCalBtn');
  const agcToggle = document.getElementById('agcToggle');
  const limiterToggle = document.getElementById('limiterToggle');
  const savePresetBtn = document.getElementById('savePresetBtn');
  const loadPresetBtn = document.getElementById('loadPresetBtn');
  const emergencyBtn = document.getElementById('emergencyBtn');

  // Captions
  const captionsToggle = document.getElementById('captionsToggle');
  const captionPanel = document.getElementById('captionPanel');
  const captionBox = document.getElementById('captionBox');
  const captionClearBtn = document.getElementById('captionClearBtn');
  const captionLang = document.getElementById('captionLang');
  const captionSize = document.getElementById('captionSize');
  const capDot = document.getElementById('capDot');
  const capStatus = document.getElementById('capStatus');

  // === Theme (saves) ===
  themeSelect.value = localStorage.getItem('earassist_theme') || themeSelect.value;
  document.body.dataset.theme = themeSelect.value;
  themeSelect.onchange = () => {
    localStorage.setItem('earassist_theme', themeSelect.value);
    document.body.dataset.theme = themeSelect.value;
  };

  // Persist caption prefs
  captionsToggle.checked = (localStorage.getItem('earassist_captions') === '1');
  captionLang.value = localStorage.getItem('earassist_caption_lang') || captionLang.value;
  captionSize.value = localStorage.getItem('earassist_caption_size') || captionSize.value;

  // === State ===
  let audioCtx, mediaStream, source, dest;
  let userGain, hpFilter, lpFilter, notch, presence;
  let preGateAnalyser, postAnalyser;
  let gateGain, limiter;
  let drawReq, controlTimer;

  const dpr = window.devicePixelRatio||1;
  function sizeCanvas(){
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = 220 * dpr;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  addEventListener('resize', sizeCanvas); sizeCanvas();

  // === Helpers ===
  function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
  function computeRMSFromTimeBytes(buf){
    let s=0;
    for (let i=0;i<buf.length;i++){
      const x = (buf[i]-128)/128;
      s += x*x;
    }
    return Math.sqrt(s/buf.length);
  }
  function rmsToDb(rms){ return 20*Math.log10(Math.max(1e-8, rms)); }
  function cssVar(name){ return getComputedStyle(document.body).getPropertyValue(name).trim() || '#39ff14'; }
  function disconnectSafe(n){ try{ n && n.disconnect(); }catch{} }

  // === Device list ===
  async function listDevices(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const ins = devs.filter(d=>d.kind==='audioinput');
    const outs = devs.filter(d=>d.kind==='audiooutput');

    const prevIn = localStorage.getItem('earassist_mic') || '';
    const prevOut = localStorage.getItem('earassist_out') || '';

    micSelect.innerHTML = '<option value="">Default Microphone</option>';
    outSelect.innerHTML = '<option value="">Default Output</option>';

    ins.forEach(d => {
      const o = document.createElement('option');
      o.value = d.deviceId; o.text = d.label || 'Mic';
      micSelect.appendChild(o);
    });
    outs.forEach(d => {
      const o = document.createElement('option');
      o.value = d.deviceId; o.text = d.label || 'Output';
      outSelect.appendChild(o);
    });

    if ([...micSelect.options].some(o=>o.value===prevIn)) micSelect.value = prevIn;
    if ([...outSelect.options].some(o=>o.value===prevOut)) outSelect.value = prevOut;
  }
  await listDevices();
  navigator.mediaDevices.addEventListener('devicechange', listDevices);
  micSelect.addEventListener('change', ()=> localStorage.setItem('earassist_mic', micSelect.value));
  outSelect.addEventListener('change', async ()=> {
    localStorage.setItem('earassist_out', outSelect.value);
    if (audioOut.setSinkId && outSelect.value){
      try { await audioOut.setSinkId(outSelect.value); } catch {}
    }
  });

  // === Smart Gate Settings ===
  const gateCfg = {
    openDb: -45,
    closeDb: -50,
    holdMs: 250,
    floorGain: 0.18,
    attackTau: 0.015,
    releaseTau: 0.08
  };
  let gateIsOpen = true;
  let lastGateOpenMs = 0;

  // === Medical AGC Settings ===
  const agcCfg = {
    targetRms: 0.16,
    maxGain: 2.2,
    minGain: 0.3,
    speed: 0.035,
  };
  let userMuted = false;

  // === Audio graph ===
  function buildChain(){
    if (!audioCtx || !source || !dest) return;
    [userGain, hpFilter, lpFilter, notch, presence, preGateAnalyser, gateGain, limiter, postAnalyser].forEach(disconnectSafe);

    userGain = audioCtx.createGain();
    userGain.gain.value = clamp(parseFloat(gainCtrl.value)||1.0, agcCfg.minGain, agcCfg.maxGain);

    hpFilter = audioCtx.createBiquadFilter(); hpFilter.type='highpass'; hpFilter.frequency.value=parseFloat(hpCtrl.value)||150;
    lpFilter = audioCtx.createBiquadFilter(); lpFilter.type='lowpass';  lpFilter.frequency.value=parseFloat(lpCtrl.value)||6000;

    notch = audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=60; notch.Q.value=20;
    presence = audioCtx.createBiquadFilter(); presence.type='peaking'; presence.frequency.value=2800; presence.Q.value=1.2; presence.gain.value=4.0;

    preGateAnalyser = audioCtx.createAnalyser(); preGateAnalyser.fftSize = 1024;
    gateGain = audioCtx.createGain(); gateGain.gain.value = 1.0;

    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value = -6;
    limiter.knee.value = 0;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.002;
    limiter.release.value = 0.06;

    postAnalyser = audioCtx.createAnalyser(); postAnalyser.fftSize = 1024;

    source.connect(userGain);
    userGain.connect(hpFilter);
    hpFilter.connect(lpFilter);

    let node = lpFilter;
    if (notchToggle.checked){ node.connect(notch); node = notch; }
    if (presenceToggle.checked){ node.connect(presence); node = presence; }

    node.connect(preGateAnalyser);
    node.connect(gateGain);

    let outNode = gateGain;
    if (limiterToggle.checked){ outNode.connect(limiter); outNode = limiter; }

    outNode.connect(postAnalyser);
    postAnalyser.connect(dest);

    if (outSelect.value && audioOut.setSinkId){
      audioOut.setSinkId(outSelect.value).catch(()=>{});
    }
  }

  // === Start/Stop ===
  startBtn.onclick = async () => {
    if (audioCtx) return;

    const cons = { audio: { deviceId: micSelect.value ? { exact: micSelect.value } : undefined } };
    mediaStream = await navigator.mediaDevices.getUserMedia(cons);
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });

    dest = audioCtx.createMediaStreamDestination();
    audioOut.srcObject = dest.stream;

    source = audioCtx.createMediaStreamSource(mediaStream);

    const assistBtn = document.querySelector('.preset[data-type="assist"]');
    if (assistBtn) markActivePreset(assistBtn);

    buildChain();

    clearInterval(controlTimer);
    controlTimer = setInterval(controlStep, 50);

    tickDraw();

    // If captions already enabled, start them too
    if (captionsToggle.checked) {
      captionPanel.style.display = '';
      startCaptions();
    }
  };

  stopBtn.onclick = async () => {
    if (!audioCtx) return;
    const ok = confirm('Stop audio processing?');
    if (!ok) return;

    try { cancelAnimationFrame(drawReq); } catch {}
    try { clearInterval(controlTimer); controlTimer = null; } catch {}

    stopCaptions(true);

    try { mediaStream?.getTracks()?.forEach(t=>t.stop()); } catch {}
    try { [source, userGain, hpFilter, lpFilter, notch, presence, preGateAnalyser, gateGain, limiter, postAnalyser].forEach(disconnectSafe); } catch {}
    try { audioOut.srcObject = null; } catch {}
    try { await audioCtx.close(); } catch {}

    audioCtx = null; dest = null;
    gateState.textContent = '--';
    latencyVal.textContent = '--';
  };

  muteBtn.onclick = () => {
    userMuted = true;
    if (userGain){ userGain.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.01); }
    gainCtrl.value = '0.00'; gainVal.textContent='0.00';
  };

  // === UI events ===
  gainCtrl.oninput = () => {
    userMuted = false;
    const v = clamp(parseFloat(gainCtrl.value), agcCfg.minGain, agcCfg.maxGain);
    gainVal.textContent = v.toFixed(2);
    if (userGain) userGain.gain.setTargetAtTime(v, audioCtx.currentTime, 0.02);
  };
  hpCtrl.oninput = () => { hpVal.textContent=hpCtrl.value; if(hpFilter) hpFilter.frequency.setTargetAtTime(parseFloat(hpCtrl.value), audioCtx.currentTime, 0.03); };
  lpCtrl.oninput = () => { lpVal.textContent=lpCtrl.value; if(lpFilter) lpFilter.frequency.setTargetAtTime(parseFloat(lpCtrl.value), audioCtx.currentTime, 0.03); };

  notchToggle.onchange = presenceToggle.onchange = limiterToggle.onchange = gateToggle.onchange = () => { if(audioCtx) buildChain(); };

  presets.forEach(btn => btn.onclick = () => {
    markActivePreset(btn);

    if (btn.dataset.type==='assist'){
      hpCtrl.value=350; lpCtrl.value=4500; gainCtrl.value=1.15;
      presenceToggle.checked=true; gateToggle.checked=true; notchToggle.checked=true;
      gateCfg.floorGain = 0.20; gateCfg.holdMs = 320; gateCfg.attackTau = 0.02; gateCfg.releaseTau = 0.10;
      agcCfg.targetRms = 0.17; agcCfg.speed = 0.028;
    }
    if (btn.dataset.type==='speech'){
      hpCtrl.value=200; lpCtrl.value=4000; gainCtrl.value=1.20;
      presenceToggle.checked=true; gateToggle.checked=true; notchToggle.checked=false;
      gateCfg.floorGain = 0.20; gateCfg.holdMs = 260;
      agcCfg.targetRms = 0.16; agcCfg.speed = 0.032;
    }
    if (btn.dataset.type==='noise'){
      hpCtrl.value=400; lpCtrl.value=3000; gainCtrl.value=1.00;
      presenceToggle.checked=false; gateToggle.checked=true; notchToggle.checked=true;
      gateCfg.floorGain = 0.15; gateCfg.holdMs = 320;
      agcCfg.targetRms = 0.15; agcCfg.speed = 0.030;
    }
    if (btn.dataset.type==='natural'){
      hpCtrl.value=100; lpCtrl.value=8000; gainCtrl.value=1.00;
      presenceToggle.checked=false; gateToggle.checked=false; notchToggle.checked=false;
      agcCfg.targetRms = 0.16; agcCfg.speed = 0.035;
    }

    gainCtrl.oninput(); hpCtrl.oninput(); lpCtrl.oninput();
    if (audioCtx) buildChain();
  });

  emergencyBtn.onclick = () => {
    hpCtrl.value = 420;
    lpCtrl.value = 3800;
    presenceToggle.checked = true;
    notchToggle.checked = true;
    gateToggle.checked = true;
    limiterToggle.checked = true;
    gainCtrl.value = clamp((parseFloat(gainCtrl.value)||1.1) + 0.20, agcCfg.minGain, agcCfg.maxGain).toFixed(2);
    gateCfg.holdMs = 420; gateCfg.floorGain = 0.22; gateCfg.releaseTau = 0.12;

    gainCtrl.oninput(); hpCtrl.oninput(); lpCtrl.oninput();
    if (audioCtx) buildChain();
  };

  nrCalBtn.onclick = () => {
    if (!preGateAnalyser) return;
    const buf = new Uint8Array(preGateAnalyser.fftSize);
    preGateAnalyser.getByteTimeDomainData(buf);
    const rms = computeRMSFromTimeBytes(buf);
    const db = rmsToDb(rms);

    gateCfg.closeDb = clamp(db + 6, -70, -30);
    gateCfg.openDb  = clamp(db + 10, gateCfg.closeDb + 2, -25);

    alert('Noise calibrated.');
  };

  // === Save/Load preset ===
  savePresetBtn.onclick = () => {
    const preset = {
      gain: parseFloat(gainCtrl.value),
      hp: parseFloat(hpCtrl.value),
      lp: parseFloat(lpCtrl.value),
      notch: notchToggle.checked,
      gate: gateToggle.checked,
      presence: presenceToggle.checked,
      agc: agcToggle.checked,
      limiter: limiterToggle.checked,
      theme: themeSelect.value,
      gateCfg: gateCfg,
      agcCfg: agcCfg,
      captions: captionsToggle.checked,
      capLang: captionLang.value,
      capSize: captionSize.value
    };
    localStorage.setItem('earassist_v6_preset', JSON.stringify(preset));
    alert('Preset saved.');
  };

  loadPresetBtn.onclick = () => {
    const p = localStorage.getItem('earassist_v6_preset');
    if (!p) { alert('No preset found.'); return; }
    try {
      const preset = JSON.parse(p);

      gainCtrl.value = (preset.gain ?? 1.0).toFixed(2);
      hpCtrl.value = preset.hp ?? 150;
      lpCtrl.value = preset.lp ?? 6000;

      notchToggle.checked = !!preset.notch;
      gateToggle.checked = preset.gate !== false;
      presenceToggle.checked = !!preset.presence;
      agcToggle.checked = preset.agc !== false;
      limiterToggle.checked = preset.limiter !== false;

      themeSelect.value = preset.theme || 'dark';
      localStorage.setItem('earassist_theme', themeSelect.value);
      document.body.dataset.theme = themeSelect.value;

      if (preset.gateCfg) Object.assign(gateCfg, preset.gateCfg);
      if (preset.agcCfg) Object.assign(agcCfg, preset.agcCfg);

      // captions prefs
      captionsToggle.checked = !!preset.captions;
      captionLang.value = preset.capLang || captionLang.value;
      captionSize.value = preset.capSize || captionSize.value;

      applyCaptionUiPrefs();

      gainCtrl.oninput(); hpCtrl.oninput(); lpCtrl.oninput();
      if (audioCtx) buildChain();

      // start/stop captions based on toggle
      if (captionsToggle.checked){
        captionPanel.style.display = '';
        startCaptions();
      } else {
        stopCaptions(false);
        captionPanel.style.display = 'none';
      }

      alert('Preset loaded.');
    } catch(e){
      alert('Invalid preset.');
    }
  };

  // === Control loop: Smart Gate + Medical AGC ===
  function controlStep(){
    if (!audioCtx || !preGateAnalyser || !gateGain) return;

    const buf = new Uint8Array(preGateAnalyser.fftSize);
    preGateAnalyser.getByteTimeDomainData(buf);
    const rms = computeRMSFromTimeBytes(buf);
    const db = rmsToDb(rms);
    const nowMs = performance.now();

    if (gateToggle.checked){
      if (db >= gateCfg.openDb){
        gateIsOpen = true;
        lastGateOpenMs = nowMs;
      } else if (db <= gateCfg.closeDb){
        if ((nowMs - lastGateOpenMs) > gateCfg.holdMs){
          gateIsOpen = false;
        }
      }
      const target = gateIsOpen ? 1.0 : gateCfg.floorGain;
      const tau = gateIsOpen ? gateCfg.attackTau : gateCfg.releaseTau;
      gateGain.gain.setTargetAtTime(target, audioCtx.currentTime, tau);
      gateState.textContent = gateIsOpen ? 'OPEN' : 'SOFT';
    } else {
      gateIsOpen = true;
      gateGain.gain.setTargetAtTime(1.0, audioCtx.currentTime, 0.03);
      gateState.textContent = 'OFF';
    }

    if (agcToggle.checked && userGain && !userMuted){
      const gateFactor = gateToggle.checked ? (gateIsOpen ? 1.0 : 0.0) : 1.0;
      if (gateFactor > 0.5){
        const target = agcCfg.targetRms;
        const err = target - rms;
        const current = userGain.gain.value;
        const next = clamp(current + err * agcCfg.speed, agcCfg.minGain, agcCfg.maxGain);
        userGain.gain.setTargetAtTime(next, audioCtx.currentTime, 0.08);

        const shown = clamp(parseFloat(gainCtrl.value)||next, agcCfg.minGain, agcCfg.maxGain);
        const blended = (shown*0.85 + next*0.15);
        gainCtrl.value = blended.toFixed(2);
        gainVal.textContent = gainCtrl.value;
      }
    }
  }

  // === Draw loop (uses postAnalyser) ===
  function tickDraw(){
    if (!audioCtx || !postAnalyser) return;

    function draw(){
      const w = canvas.clientWidth, h = 220;
      ctx.clearRect(0,0,w,h);

      const accent = cssVar('--accent');

      if (vizMode.value==='wave' || vizMode.value==='split'){
        const td = new Uint8Array(postAnalyser.fftSize);
        postAnalyser.getByteTimeDomainData(td);
        ctx.beginPath();
        const step = w/td.length;
        for (let i=0;i<td.length;i++){
          const y = h/2 + (td[i]-128)/128 * (h/2-2);
          if (i===0) ctx.moveTo(0,y); else ctx.lineTo(i*step,y);
        }
        ctx.lineWidth = 2; ctx.strokeStyle = accent; ctx.globalAlpha = 0.9;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      if (vizMode.value==='spectrum' || vizMode.value==='split'){
        const fd = new Uint8Array(postAnalyser.frequencyBinCount);
        postAnalyser.getByteFrequencyData(fd);
        const barW = w/fd.length;
        ctx.globalAlpha = 0.55;
        ctx.fillStyle = accent;
        for (let i=0;i<fd.length;i++){
          const v = fd[i]/255;
          const barH = v*h;
          ctx.fillRect(i*barW, h-barH, Math.max(1,barW-1), barH);
        }
        ctx.globalAlpha = 1;
      }

      latencyVal.textContent = audioCtx.baseLatency ? (audioCtx.baseLatency*1000).toFixed(1) : '--';
      drawReq = requestAnimationFrame(draw);
    }

    draw();
  }

  // Default preset highlight
  const assistBtn = document.querySelector('.preset[data-type="assist"]');
  if (assistBtn) markActivePreset(assistBtn);

  // =====================
  // Live Captions Engine
  // =====================
  let recognition = null;
  let captionsEnabled = captionsToggle.checked;
  let lastFinal = "";     // committed text
  let lastInterim = "";   // live partial
  let restarting = false;

  function setCapStatus(on, text){
    capDot.classList.toggle('on', !!on);
    capStatus.textContent = text || (on ? 'Listening…' : 'Off');
  }

  function applyCaptionUiPrefs(){
    localStorage.setItem('earassist_caption_lang', captionLang.value);
    localStorage.setItem('earassist_caption_size', captionSize.value);
    captionBox.style.fontSize = (parseInt(captionSize.value,10) || 22) + 'px';
  }
  applyCaptionUiPrefs();

  captionLang.onchange = () => {
    applyCaptionUiPrefs();
    if (recognition && captionsEnabled){
      // restart with new language
      stopCaptions(false);
      startCaptions();
    }
  };
  captionSize.onchange = applyCaptionUiPrefs;

  captionClearBtn.onclick = () => {
    lastFinal = ""; lastInterim = "";
    captionBox.innerHTML = '<span class="captionDim">Cleared.</span>';
  };

  captionsToggle.onchange = () => {
    captionsEnabled = captionsToggle.checked;
    localStorage.setItem('earassist_captions', captionsEnabled ? '1' : '0');

    if (captionsEnabled){
      captionPanel.style.display = '';
      startCaptions();
    } else {
      stopCaptions(false);
      captionPanel.style.display = 'none';
    }
  };

  function isSpeechRecognitionSupported(){
    return !!(window.SpeechRecognition || window.webkitSpeechRecognition);
  }

  function startCaptions(){
    if (!captionsEnabled) return;

    if (!isSpeechRecognitionSupported()){
      captionPanel.style.display = '';
      captionBox.innerHTML = '<span class="captionDim">Live Captions are not supported in this browser. Try Chrome for best results.</span>';
      setCapStatus(false, 'Unsupported');
      return;
    }

    if (recognition) {
      try { recognition.stop(); } catch {}
      recognition = null;
    }

    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SR();
    recognition.lang = captionLang.value || 'en-CA';
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.maxAlternatives = 1;

    restarting = false;
    setCapStatus(true, 'Listening…');

    recognition.onstart = () => {
      setCapStatus(true, 'Listening…');
      if (!lastFinal && !lastInterim){
        captionBox.innerHTML = '<span class="captionDim">Listening…</span>';
      }
    };

    recognition.onerror = (e) => {
      // Don’t spam alerts; show status only.
      const msg = (e && e.error) ? e.error : 'error';
      setCapStatus(false, 'Error: ' + msg);
      // Many errors are transient (no-speech, audio-capture, network).
      // We attempt a gentle restart if still enabled.
      if (captionsEnabled){
        scheduleRestart();
      }
    };

    recognition.onend = () => {
      // Auto-restart if user still wants captions
      if (captionsEnabled){
        scheduleRestart();
      } else {
        setCapStatus(false, 'Off');
      }
    };

    recognition.onresult = (event) => {
      let interim = '';
      for (let i = event.resultIndex; i < event.results.length; i++){
        const res = event.results[i];
        const txt = (res[0] && res[0].transcript) ? res[0].transcript : '';
        if (res.isFinal){
          lastFinal = (lastFinal + ' ' + txt).trim();
          lastInterim = '';
        } else {
          interim += txt;
        }
      }
      lastInterim = interim.trim();

      const safeFinal = escapeHtml(lastFinal);
      const safeInterim = escapeHtml(lastInterim);

      if (!safeFinal && !safeInterim){
        captionBox.innerHTML = '<span class="captionDim">Listening…</span>';
      } else if (safeFinal && safeInterim){
        captionBox.innerHTML = `<span class="captionDim">${safeFinal}</span>\n<span class="captionLive">${safeInterim}</span>`;
      } else if (safeFinal){
        captionBox.innerHTML = `<span class="captionLive">${safeFinal}</span>`;
      } else {
        captionBox.innerHTML = `<span class="captionLive">${safeInterim}</span>`;
      }

      // Auto-scroll to bottom
      captionBox.scrollTop = captionBox.scrollHeight;
      setCapStatus(true, 'Listening…');
    };

    try {
      recognition.start();
    } catch (e) {
      // Some browsers throw if start called too fast
      setCapStatus(false, 'Start blocked');
      scheduleRestart();
    }
  }

  function stopCaptions(resetStatus){
    captionsEnabled = captionsToggle.checked;
    if (recognition){
      try { recognition.onend = null; } catch {}
      try { recognition.stop(); } catch {}
      recognition = null;
    }
    if (resetStatus){
      setCapStatus(false, 'Off');
    } else {
      setCapStatus(false, captionsEnabled ? 'Restarting…' : 'Off');
    }
  }

  function scheduleRestart(){
    if (!captionsEnabled) return;
    if (restarting) return;
    restarting = true;
    setCapStatus(false, 'Restarting…');
    setTimeout(() => {
      restarting = false;
      if (captionsEnabled) startCaptions();
    }, 650);
  }

  function escapeHtml(s){
    return (s || '').replace(/[&<>"']/g, function(m){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[m];
    });
  }

  // If captions were enabled on load, show panel (they will start when user clicks Start OR toggles on)
  if (captionsEnabled){
    captionPanel.style.display = '';
  } else {
    captionPanel.style.display = 'none';
  }

})();
</script>

<script>
  // PWA: service worker (works on https or localhost)
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    });
  }
</script>

</body>
</html>
