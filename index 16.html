<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AirAssist v4 — All-In-One (Working Build)</title>
  <style>
    :root { --bg:#0f1115; --fg:#e6edf3; --accent:#39ff14; --muted:#8aa3b0; --panel:#171a21; --line:#ffffff; --good:#1ee0a2; --warn:#ffb300; --bad:#ff5a5f; }
    [data-theme="light"] {
  --bg: #f7f9fc;       /* gentle pastel base */
  --fg: #222;          /* readable dark gray text */
  --accent: #3b82f6;   /* bright blue accent */
  --muted: #6b7280;    /* softer gray */
  --panel: #ffffff;    /* panels */
  --line: #cbd5e1;     /* blue-gray borders */
  --good: #10b981;     /* emerald */
  --warn: #f59e0b;     /* amber */
  --bad: #ef4444;      /* red */
}

/* Checkboxes in Light theme */
[data-theme="light"] input[type=checkbox] {
  accent-color: var(--accent);
  background: #fff;
  border: 1px solid var(--line);
}
[data-theme="light"] input[type=checkbox]:checked {
  background: var(--accent);
}

/* Sliders in Light theme */
[data-theme="light"] input[type=range] {
  accent-color: var(--accent);
  background: #f0f0f0;
}

/* Panels in Light theme */
[data-theme="light"] .panel {
  background: #f7f9fc;
  border: 1px solid var(--line);
}

/* Inactive buttons */
[data-theme="light"] .preset button,
[data-theme="light"] .panel button,
[data-theme="light"] .controls button {
  background: #ffffff;
  color: #222 !important;
  border: 1px solid var(--line);
}

/* Active buttons */
[data-theme="light"] .preset button.active,
[data-theme="light"] .panel button.active,
[data-theme="light"] .controls button.active {
  background: var(--accent);
  color: #ffffff !important;
  border: 1px solid #2563eb;
}


/* Inactive buttons in Light theme */
[data-theme="light"] .preset button,
[data-theme="light"] .panel button,
[data-theme="light"] .controls button {
  background: #ffffff;
  color: #222 !important;
  border: 1px solid var(--line);
}

/* Active buttons (toggled on) */
[data-theme="light"] .preset button.active,
[data-theme="light"] .panel button.active,
[data-theme="light"] .controls button.active {
  background: var(--accent);
  color: #ffffff !important;
  border: 1px solid #2563eb;
}

/* Hover readability */
[data-theme="light"] .preset button:hover,
[data-theme="light"] .panel button:hover,
[data-theme="light"] .controls button:hover {
  filter: brightness(0.95);
}


/* White-panel buttons (presets, toggle styles) */
[data-theme="light"] .preset button,
[data-theme="light"] .panel button {
  background: #fff;
  color: #222 !important;   /* dark text on white */
  border: 1px solid var(--line);
}

/* Hover states */
[data-theme="light"] button:hover {
  filter: brightness(0.9);
}

/* Inputs, selects, knobs */
[data-theme="light"] input,
[data-theme="light"] select,
[data-theme="light"] .knob {
  color: #222 !important;
  background: #fff;
  border: 1px solid var(--line);
}


/* Light theme buttons */
[data-theme="light"] button {
  background: var(--accent);
  color: #ffffff !important;   /* force white text */
  font-weight: 600;            /* bold for visibility */
  border: 1px solid #2563eb;
  border-radius: 6px;
  padding: 6px 12px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.15);
  transition: background .2s, box-shadow .2s;
}
[data-theme="light"] button:hover {
  background: #2563eb;
  color: #ffffff !important;
  box-shadow: 0 3px 6px rgba(0,0,0,0.25);
}
    [data-theme="solar"]{ --bg:#bfa873; --fg:#fdf6e3; --accent:#b58900; --muted:#6c7a80; --panel:#8c7a50; --line:#fce48c; --good:#2aa198; --warn:#cb4b16; --bad:#dc322f; }
    [data-theme="ocean"]{ --bg:#003344; --fg:#d6deeb; --accent:#2bbac5; --muted:#9fb3c8; --panel:#005577; --line:#007799; --good:#22d3ee; --warn:#eab308; --bad:#fb7185; }
    [data-theme="orange"]{ --bg:#402000; --fg:#fff0e0; --accent:#ff8a00; --muted:#ffd166; --panel:#663300; --line:#ffd166; --good:#ffd166; --warn:#ffa600; --bad:#ef476f; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; background:var(--bg); color:var(--fg); }
    header { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid var(--line); background:var(--panel); position:sticky; top:0; z-index:10; }
    h1 { margin:0; font-size:18px; letter-spacing:.3px; font-weight:700; }
    .row { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; }
    select, button, input[type="range"] { background:#0d121a; color:var(--fg); border:1px solid var(--line); padding:8px 10px; border-radius:10px; }
    [data-theme="light"] select, [data-theme="light"] button, [data-theme="light"] input[type="range"] { background:#fff; }
    button { cursor:pointer; border:1px solid var(--line); background:var(--panel); transition:transform .05s ease, background .2s ease, border-color .2s ease; }
    button:hover { border-color:var(--accent); }
    button:active { transform:translateY(1px); }
    .primary { background:var(--accent); color:#001013; border-color:transparent; }
    main { max-width:1100px; margin:18px auto; padding:0 16px 24px; }
    .grid { display:grid; gap:12px; grid-template-columns: repeat(12, 1fr); }
    .card { grid-column: span 12; background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:12px 14px; box-shadow: 0 6px 14px rgba(0,0,0,.18); }
    .card h3 { margin:4px 0 10px; font-size:14px; opacity:.9; letter-spacing:.3px; }
    .k { background:#0b1320; border:1px solid var(--line); padding:8px 10px; border-radius:10px; display:inline-flex; gap:8px; align-items:center; }
    label { font-size:13px; opacity:.95; }
    .small { font-size:12px; opacity:.7; }
    .pill { padding:8px 12px; border-radius:999px; border:1px solid var(--line); background:transparent; }
    .bars { display:flex; align-items:center; gap:10px; }
    .bars .g { flex:1; }
    .split { display:grid; grid-template-columns:1fr 1fr; gap:12px; }
    @media (max-width:900px){ .split{ grid-template-columns:1fr; } }
    canvas { width:100%; height:220px; background:#0a0f18; border-radius:12px; border:1px solid var(--line); }
  
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none;
  appearance:none;
  width:16px; height:16px;
  border-radius:50%;
  cursor:pointer;
  border:2px solid var(--line);
  background:var(--accent);
}
input[type=range]::-moz-range-thumb {
  width:16px; height:16px;
  border-radius:50%;
  cursor:pointer;
  border:2px solid var(--line);
  background:var(--accent);
}
input[type=range]::-webkit-slider-runnable-track {
  height:6px;
  border-radius:6px;
  background:var(--line);
}
input[type=range]::-moz-range-track {
  height:6px;
  border-radius:6px;
  background:var(--line);
}
input[type=range]:hover::-webkit-slider-thumb,
input[type=range]:hover::-moz-range-thumb {
  box-shadow:0 0 6px var(--accent);
}
[data-theme="light"] input[type=range]::-webkit-slider-thumb,
[data-theme="light"] input[type=range]::-moz-range-thumb {
  background:#000;
  border:2px solid #fff;
}
[data-theme="light"] input[type=range]::-webkit-slider-runnable-track,
[data-theme="light"] input[type=range]::-moz-range-track {
  background:#d0d0d0;
}
[data-theme="dark"] input[type=range]::-webkit-slider-thumb,
[data-theme="dark"] input[type=range]::-moz-range-thumb {
  background:#39ff14;
  border:2px solid #fff;
}
[data-theme="dark"] input[type=range]::-webkit-slider-runnable-track,
[data-theme="dark"] input[type=range]::-moz-range-track {
  background:#444;
}


/* Slider Track Styling */
input[type=range]::-webkit-slider-runnable-track {
  height:8px;
  border-radius:8px;
  background:linear-gradient(90deg, var(--accent) 0%, var(--muted) 50%, var(--accent) 100%);
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
}
input[type=range]::-moz-range-track {
  height:8px;
  border-radius:8px;
  background:linear-gradient(90deg, var(--accent) 0%, var(--muted) 50%, var(--accent) 100%);
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
}

/* Slider Thumb Styling */
input[type=range]::-webkit-slider-thumb {
  -webkit-appearance:none;
  appearance:none;
  width:20px; height:20px;
  border-radius:50%;
  background:var(--accent);
  border:2px solid #fff;
  box-shadow:0 2px 5px rgba(0,0,0,0.6), inset 0 2px 3px rgba(255,255,255,0.4);
  cursor:pointer;
  margin-top:-6px; /* center thumb on track */
}
input[type=range]::-moz-range-thumb {
  width:20px; height:20px;
  border-radius:50%;
  background:var(--accent);
  border:2px solid #fff;
  box-shadow:0 2px 5px rgba(0,0,0,0.6), inset 0 2px 3px rgba(255,255,255,0.4);
  cursor:pointer;
}

/* Hover/Active Effects */
input[type=range]:hover::-webkit-slider-thumb,
input[type=range]:active::-webkit-slider-thumb,
input[type=range]:hover::-moz-range-thumb,
input[type=range]:active::-moz-range-thumb {
  box-shadow:0 0 10px var(--accent), 0 2px 5px rgba(0,0,0,0.6);
}

/* Light Theme Specific */
[data-theme="light"] input[type=range]::-webkit-slider-thumb,
[data-theme="light"] input[type=range]::-moz-range-thumb {
  background:#000;
  border:2px solid #fff;
}
[data-theme="light"] input[type=range]::-webkit-slider-runnable-track,
[data-theme="light"] input[type=range]::-moz-range-track {
  background:linear-gradient(90deg, #000 0%, #d0d0d0 50%, #000 100%);
}

/* Dark Theme Specific */
[data-theme="dark"] input[type=range]::-webkit-slider-thumb,
[data-theme="dark"] input[type=range]::-moz-range-thumb {
  background:#39ff14;
  border:2px solid #fff;
}
[data-theme="dark"] input[type=range]::-webkit-slider-runnable-track,
[data-theme="dark"] input[type=range]::-moz-range-track {
  background:linear-gradient(90deg, #39ff14 0%, #444 50%, #39ff14 100%);
}


/* === Button Polish === */
button {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px 14px;
  font-weight: 600;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.5);
  border-color: var(--accent);
}
button:active {
  transform: translateY(1px);
  box-shadow: inset 0 2px 4px rgba(0,0,0,0.4);
}
button.primary {
  background: linear-gradient(180deg, var(--accent), #00000020);
  color: #fff;
  border: none;
}

/* === Toggle Switch (Checkbox) Polish === */
.k input[type=checkbox] {
  -webkit-appearance: none;
  appearance: none;
  width: 38px; height: 20px;
  border-radius: 20px;
  border: 2px solid var(--line);
  background: var(--muted);
  position: relative;
  outline: none;
  cursor: pointer;
  transition: background 0.3s, border-color 0.3s;
}
.k input[type=checkbox]::before {
  content: "";
  position: absolute;
  top: 2px; left: 2px;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: #fff;
  transition: transform 0.3s;
  box-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
.k input[type=checkbox]:checked {
  background: var(--accent);
  border-color: var(--accent);
}
.k input[type=checkbox]:checked::before {
  transform: translateX(18px);
  background: #fff;
}


/* Light theme filter card text fix */
[data-theme="light"] .k {
  color: #000 !important;
  font-weight: 600;
}


/* Active preset pill */
.preset.is-active{
  background: var(--accent);
  color: #000;
  border-color: var(--accent);
  box-shadow: 0 0 10px rgba(0,0,0,.35);
}
.preset:focus-visible{ outline: 2px solid var(--accent); outline-offset: 2px; }

/* Global focus ring */
:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:8px; }

/* Simple tooltips */
[aria-label] { position: relative; }
[aria-label]:hover::after{
  content: attr(aria-label);
  position:absolute; bottom:calc(100% + 6px); left:50%; transform:translateX(-50%);
  background: var(--panel); color: var(--fg);
  border: 1px solid var(--line); border-radius: 8px; padding: 6px 8px; font-size: 12px; white-space:nowrap;
  box-shadow: 0 4px 12px rgba(0,0,0,.35); z-index: 5;
}

</style>
</head>
<body>
  <header>
    <h1>AirAssist v4 — All-In-One</h1>
    <div class="row">
      <label>Theme
        <select id="themeSelect">
          <option value="dark">Dark</option>
          <option value="light">Light</option>
          <option value="solar">Solar</option>
          <option value="ocean">Ocean</option>
          <option value="orange">Orange</option>
        </select>
      </label>
      <label>Mic <select id="micSelect"></select></label>
      <label>Output <select id="outSelect"></select></label>
      <button id="startBtn" class="primary">Start</button>
      <button id="bypassBtn">Bypass</button>
    <button id="stopBtn">Stop</button>
      <button id="muteBtn">Mute</button>
      <span class="pill small">Latency: <span id="latencyVal">--</span> ms</span>
    </div>
  </header>

  <main class="grid">
    <div class="card">
      <h3>Presets</h3>
      <div class="row">
        <button class="pill preset" data-type="speech">Speech Clear</button>
        <button class="pill preset" data-type="noise">Noise Cut</button>
        <button class="pill preset" data-type="natural">Natural</button>
      </div>
    </div>

    <div class="card">
      <h3>EQ</h3>
      <div class="bars">
        <div class="g"><label>Gain <span id="gainVal">1.00</span>x</label><input id="gainCtrl" type="range" min="0.2" max="2.5" step="0.01" value="1.00"></div>
        <div class="g"><label>High‑pass <span id="hpVal">150</span> Hz</label><input id="hpCtrl" type="range" min="20" max="1000" step="10" value="150"></div>
        <div class="g"><label>Low‑pass <span id="lpVal">6000</span> Hz</label><input id="lpCtrl" type="range" min="1000" max="12000" step="100" value="6000"></div>
      </div>
    </div>

    <div class="card">
      <h3>Filters</h3>
      <div class="row">
        <label class="k"><input id="presenceToggle" type="checkbox"> Presence Boost</label>
        <label class="k"><input id="gateToggle" type="checkbox"> Noise Gate</label>
        <label class="k"><input id="notchToggle" type="checkbox"> Notch 60Hz</label>
      </div>
    </div>

    <div class="card" id="dspControls">
      <h3>Assist Controls</h3>
      <div class="row">
        <button id="nrCalBtn" aria-label="Set noise gate to current room noise">Calibrate Noise</button>
        <label class="k"><input id="agcToggle" type="checkbox"> Auto‑Gain (AGC)</label>
        <label class="k"><input id="limiterToggle" type="checkbox" checked> Limiter</label>
        <button id="savePresetBtn">Save Preset</button>
        <button id="loadPresetBtn">Load Preset</button>
      </div>
      <div class="small">Tip: run Calibrate Noise in a quiet moment to set the gate threshold automatically.</div>
    </div>

    <div class="card split">
      <div><h3>Visualizer</h3><canvas id="visualizer"></canvas></div>
      <div><h3>Display</h3>
        <label>Mode
          <select id="vizMode">
            <option value="spectrum">Spectrum</option>
            <option value="wave">Waveform</option>
            <option value="split" selected>Split</option>
          </select>
        </label>
      </div>
    </div>
  </main>

  <audio id="audioOut" autoplay style="display:none"></audio>

<script>
(async function(){
  // === Elements ===
  const themeSelect = document.getElementById('themeSelect');
  const micSelect = document.getElementById('micSelect');
  const outSelect = document.getElementById('outSelect');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const muteBtn = document.getElementById('muteBtn');

  const gainCtrl = document.getElementById('gainCtrl');
  const hpCtrl = document.getElementById('hpCtrl');
  const lpCtrl = document.getElementById('lpCtrl');
  const gainVal = document.getElementById('gainVal');
  const hpVal = document.getElementById('hpVal');
  const lpVal = document.getElementById('lpVal');

  const notchToggle = document.getElementById('notchToggle');
  const gateToggle = document.getElementById('gateToggle');
  const presenceToggle = document.getElementById('presenceToggle');

  const presets = document.querySelectorAll('.preset');
  function markActivePreset(btn){
    document.querySelectorAll('.preset').forEach(b=>b.classList.remove('is-active'));
    btn.classList.add('is-active');
  }

  const vizMode = document.getElementById('vizMode');
  const latencyVal = document.getElementById('latencyVal');
  const canvas = document.getElementById('visualizer');
  const ctx = canvas.getContext('2d');
  const audioOut = document.getElementById('audioOut');

  // Assist controls
  const nrCalBtn = document.getElementById('nrCalBtn');
  const agcToggle = document.getElementById('agcToggle');
  const limiterToggle = document.getElementById('limiterToggle');
  const savePresetBtn = document.getElementById('savePresetBtn');
  const loadPresetBtn = document.getElementById('loadPresetBtn');

  // === Toast + Status Helpers ===

// === Bypass Toggle ===
const bypassBtn = document.getElementById('bypassBtn');
let bypassActive = false;
if(bypassBtn){
  bypassBtn.onclick = () => {
    bypassActive = !bypassActive;
    if(bypassActive){
      if(source){
        const dest = audioCtx.createMediaStreamDestination();
        source.connect(dest);
        audioOut.srcObject = dest.stream;
      }
      bypassBtn.textContent = 'Bypass (On)';
      showToast('Bypass enabled');
      updateStatus('Bypass', gainNode?gainNode.gain.value.toFixed(2):'--', gate?gate.threshold.value.toFixed(1):'--');
    } else {
      if(audioCtx && source){
        buildChain();
      }
      bypassBtn.textContent = 'Bypass';
      showToast('Bypass disabled');
      updateStatus('Running', gainNode?gainNode.gain.value.toFixed(2):'--', gate?gate.threshold.value.toFixed(1):'--');
    }
  };
}

function showToast(msg, time=2000){
  const t = document.getElementById('toast');
  if(!t) return; t.textContent = msg; t.style.opacity=1;
  setTimeout(()=>t.style.opacity=0, time);
}
function updateStatus(mode, gain, gate){
  const sm=document.getElementById('statusMode'); if(sm) sm.textContent=mode||'';
  const sg=document.getElementById('statusGain'); if(sg) sg.textContent=gain||'--';
  const sg2=document.getElementById('statusGate'); if(sg2) sg2.textContent=gate||'--';
}

// === Theme ===
  themeSelect.value = localStorage.getItem('airassist_theme') || themeSelect.value;
  document.body.dataset.theme = themeSelect.value;
  themeSelect.onchange = () => { localStorage.setItem('airassist_theme', themeSelect.value);
  document.body.dataset.theme = themeSelect.value; };

  // === State ===
  let audioCtx, mediaStream, source, outputElem = audioOut;
  let gainNode, hpFilter, lpFilter, notch, presence, gate, analyser, limiter;
  let drawReq, agcTimer;
  const dpr = window.devicePixelRatio||1;

  function sizeCanvas(){
    canvas.width = canvas.clientWidth * dpr;
    canvas.height = 220 * dpr;
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  addEventListener('resize', sizeCanvas); sizeCanvas();

  // === Devices ===
  async function listDevices(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const ins = devs.filter(d=>d.kind==='audioinput');
    const outs = devs.filter(d=>d.kind==='audiooutput');

    const prevIn = localStorage.getItem('airassist_mic') || '';
    const prevOut = localStorage.getItem('airassist_out') || '';

    micSelect.innerHTML = '<option value="">Default Microphone</option>';
    outSelect.innerHTML = '<option value="">Default Output</option>';
    ins.forEach(d => {
      const o = document.createElement('option');
      o.value = d.deviceId; o.text = d.label || 'Mic'; micSelect.appendChild(o);
    });
    outs.forEach(d => {
      const o = document.createElement('option');
      o.value = d.deviceId; o.text = d.label || 'Output'; outSelect.appendChild(o);
    });
    if ([...micSelect.options].some(o=>o.value===prevIn)) micSelect.value = prevIn;
    if ([...outSelect.options].some(o=>o.value===prevOut)) outSelect.value = prevOut;
  }
  await listDevices();
  const speechBtn = document.querySelector('.preset[data-type="speech"]'); if (speechBtn) markActivePreset(speechBtn);
  navigator.mediaDevices.addEventListener('devicechange', listDevices);
  
  micSelect.addEventListener('change', ()=> localStorage.setItem('airassist_mic', micSelect.value));
  outSelect.addEventListener('change', ()=> localStorage.setItem('airassist_out', outSelect.value));


  // === Helpers ===
  function computeRMS(buf){
    let s=0;
    for (let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; s+=v*v; }
    return Math.sqrt(s/buf.length);
  }

  function buildChain(){
    // disconnect safely
    try{ source.disconnect(); }catch{}
    try{ gainNode.disconnect(); }catch{}
    try{ hpFilter.disconnect(); }catch{}
    try{ lpFilter.disconnect(); }catch{}
    try{ notch.disconnect(); }catch{}
    try{ presence.disconnect(); }catch{}
    try{ gate.disconnect(); }catch{}
    try{ limiter.disconnect(); }catch{}
    try{ analyser.disconnect(); }catch{}

    // Base nodes
    gainNode = audioCtx.createGain(); gainNode.gain.value = parseFloat(gainCtrl.value)||1.0;
    hpFilter = audioCtx.createBiquadFilter(); hpFilter.type='highpass'; hpFilter.frequency.value=parseFloat(hpCtrl.value)||150;
    lpFilter = audioCtx.createBiquadFilter(); lpFilter.type='lowpass';  lpFilter.frequency.value=parseFloat(lpCtrl.value)||6000;
    notch = audioCtx.createBiquadFilter(); notch.type='notch'; notch.frequency.value=60; notch.Q.value=20;
    presence = audioCtx.createBiquadFilter(); presence.type='peaking'; presence.frequency.value=3000; presence.gain.value=4;
    gate = audioCtx.createDynamicsCompressor(); gate.threshold.value=-50; gate.knee.value=0; gate.ratio.value=20; gate.attack.value=0.003; gate.release.value=0.2;
    limiter = audioCtx.createDynamicsCompressor(); limiter.threshold.value=-6; limiter.knee.value=0; limiter.ratio.value=20; limiter.attack.value=0.001; limiter.release.value=0.05;
    analyser = audioCtx.createAnalyser(); analyser.fftSize=1024;

    // Wire
    source.connect(gainNode);
    gainNode.connect(hpFilter);
    hpFilter.connect(lpFilter);

    let node = lpFilter;
    if (notchToggle.checked){ node.connect(notch); node = notch; }
    if (presenceToggle.checked){ node.connect(presence); node = presence; }
    if (gateToggle.checked){ node.connect(gate); node = gate; }

    if (limiterToggle.checked){ node.connect(limiter); node = limiter; }
    node.connect(analyser);

    // final to output
    const dest = audioCtx.createMediaStreamDestination();
    analyser.connect(dest);
    outputElem.srcObject = dest.stream;
    if (typeof outputElem.setSinkId === 'function' && outSelect.value){
      outputElem.setSinkId(outSelect.value).catch(()=>{});
    }
  }

  // === Start/Stop ===
  startBtn.onclick = async () => {
    if (audioCtx) return;
    const cons = { audio: { deviceId: micSelect.value ? { exact: micSelect.value } : undefined } };
    mediaStream = await navigator.mediaDevices.getUserMedia(cons);
    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint:'interactive' });
    source = audioCtx.createMediaStreamSource(mediaStream);
    buildChain();
    listDevices(); // refresh labels after permission
    updateStatus('Running', gainNode.gain.value.toFixed(2), gate.threshold.value.toFixed(1));
    tick();
  };

  stopBtn.onclick = () => {
    if (!audioCtx) return;
    const ok = confirm('Stop audio processing?');
    if (!ok) return;
    cancelAnimationFrame(drawReq);
    clearInterval(agcTimer);
    try { mediaStream.getTracks().forEach(t=>t.stop()); } catch {}
    audioCtx.close(); audioCtx = null;
    updateStatus('Stopped');
  };

  let lastGainBeforeMute = 1.0; let isMuted = false;
muteBtn.onclick = () => {
  if (!gainNode) return;
  if (!isMuted) {
    lastGainBeforeMute = gainNode.gain.value;
    gainNode.gain.value = 0;
    gainCtrl.value = '0.00';
    gainVal.textContent = '0.00';
    muteBtn.textContent = 'Unmute';
  } else {
    const restored = Math.max(0.2, Math.min(2.5, lastGainBeforeMute || 1.0));
    gainNode.gain.value = restored;
    gainCtrl.value = restored.toFixed(2);
    gainVal.textContent = gainCtrl.value;
    muteBtn.textContent = 'Mute';
  }
  isMuted = !isMuted;
};

  // === UI events ===
  gainCtrl.oninput = () => { const v=Math.min(2.5, Math.max(0.2, parseFloat(gainCtrl.value)||1.0)); gainCtrl.value=v.toFixed(2); gainVal.textContent=gainCtrl.value; if(gainNode) gainNode.gain.value=v; updateStatus('Running', gainCtrl.value, gate?gate.threshold.value.toFixed(1):'--'); };
  hpCtrl.oninput   = () => { hpVal.textContent=hpCtrl.value; if(hpFilter) hpFilter.frequency.value=parseFloat(hpCtrl.value); };
  lpCtrl.oninput   = () => { lpVal.textContent=lpCtrl.value; if(lpFilter) lpFilter.frequency.value=parseFloat(lpCtrl.value); };
  notchToggle.onchange = presenceToggle.onchange = gateToggle.onchange = limiterToggle.onchange = () => { if(audioCtx) buildChain(); };

  presets.forEach(btn => btn.onclick = () => { markActivePreset(btn);
    if (btn.dataset.type==='speech'){ hpCtrl.value=200; lpCtrl.value=4000; gainCtrl.value=1.2; presenceToggle.checked=true; gateToggle.checked=true; notchToggle.checked=false; }
    if (btn.dataset.type==='noise') { hpCtrl.value=400; lpCtrl.value=3000; gainCtrl.value=1.0; presenceToggle.checked=false; gateToggle.checked=true; notchToggle.checked=true; }
    if (btn.dataset.type==='natural'){ hpCtrl.value=100; lpCtrl.value=8000; gainCtrl.value=1.0; presenceToggle.checked=false; gateToggle.checked=false; notchToggle.checked=false; }
    gainCtrl.oninput(); hpCtrl.oninput(); lpCtrl.oninput();
    if (audioCtx) buildChain();
  });

  // === Assist features ===
  // Noise calibration → set gate threshold based on ambient RMS
  nrCalBtn.onclick = () => {
    if (!analyser) return;
    const buf = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buf);
    const rms = computeRMS(buf);
    const db = 20*Math.log10(Math.max(1e-6, rms)); // rough estimate
    const th = Math.max(-80, Math.min(-30, -60 + (db * 6))); // calmer clamp
    gate.threshold.value = th;
    updateStatus('Running', gainNode?gainNode.gain.value.toFixed(2):'--', th.toFixed(1));
    showToast('Noise floor calibrated');
  };

  // AGC → nudge gain toward target RMS
  function agcStep(){
    if (!agcToggle.checked || !analyser || !gainNode) return;
    const buf = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(buf);
    const rms = computeRMS(buf);
    const target = 0.18; // ~ -15 dBFS
    const speed = 0.002;
    const err = target - rms;
    const next = Math.max(0.2, Math.min(2.5, gainNode.gain.value + err*speed));
    gainNode.gain.value = next;
    gainCtrl.value = next.toFixed(2);
    gainVal.textContent = gainCtrl.value;
  }

  savePresetBtn.onclick = () => {
    const preset = {
      gain: parseFloat(gainCtrl.value),
      hp: parseFloat(hpCtrl.value),
      lp: parseFloat(lpCtrl.value),
      notch: notchToggle.checked,
      gate: gateToggle.checked,
      presence: presenceToggle.checked,
      agc: agcToggle.checked,
      limiter: limiterToggle.checked,
      theme: themeSelect.value
    };
    localStorage.setItem('airassist_v4_preset', JSON.stringify(preset));
    showToast('Preset saved');
  };
  loadPresetBtn.onclick = () => {
    const p = localStorage.getItem('airassist_v4_preset');
    if (!p) { alert('No preset found.'); return; }
    try {
      const preset = JSON.parse(p);
      gainCtrl.value = preset.gain ?? 1.0;
      hpCtrl.value = preset.hp ?? 150;
      lpCtrl.value = preset.lp ?? 6000;
      notchToggle.checked = !!preset.notch;
      gateToggle.checked = !!preset.gate;
      presenceToggle.checked = !!preset.presence;
      agcToggle.checked = !!preset.agc;
      limiterToggle.checked = preset.limiter !== false;
      themeSelect.value = preset.theme || 'dark';
      themeSelect.value = localStorage.getItem('airassist_theme') || themeSelect.value;
  document.body.dataset.theme = themeSelect.value;
      gainCtrl.oninput(); hpCtrl.oninput(); lpCtrl.oninput();
      if (audioCtx) buildChain();
      showToast('Preset loaded');
    } catch(e){ alert('Invalid preset.'); }
  };

  // === Draw ===
  function tick(){
    if (!audioCtx) return;
    // schedule AGC
    clearInterval(agcTimer);
    agcTimer = setInterval(agcStep, 50);

    
function draw(){
  const w = canvas.clientWidth, h = 220;
  ctx.clearRect(0,0,w,h);

  if (vizMode.value==='wave' || vizMode.value==='split'){
    const td = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(td);
    ctx.beginPath();
    const step = w/td.length;
    for (let i=0;i<td.length;i++){
      const y = h/2 + (td[i]-128)/128 * (h/2-2);
      if (i===0) ctx.moveTo(0,y); else ctx.lineTo(i*step,y);
    }
    ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,255,204,.9)'; ctx.stroke();
  }

  if (vizMode.value==='spectrum' || vizMode.value==='split'){
    const fd = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(fd);
    const barW = w/fd.length;
    for (let i=0;i<fd.length;i++){
      const v = fd[i]/255;
      const barH = v*h;
      ctx.fillStyle = 'rgba(0,255,204,.6)';
      ctx.fillRect(i*barW, h-barH, Math.max(1,barW-1), barH);
    }
  }

  latencyVal.textContent = (audioCtx.baseLatency*1000).toFixed(1);
  drawReq = requestAnimationFrame(draw);
}

    draw();
  }
})();
</script>
<div id="toast" style="
  position:fixed; bottom:20px; right:20px;
  background:var(--panel); color:var(--fg);
  border:1px solid var(--line);
  padding:10px 14px; border-radius:10px;
  opacity:0; transition:opacity .3s ease;
  pointer-events:none; z-index:1000;
"></div>

<footer id="statusBar" style="
  position:fixed; bottom:0; left:0; width:100%;
  background:var(--panel); border-top:1px solid var(--line);
  padding:6px 12px; font-size:13px; opacity:.85;
  display:flex; justify-content:space-between;
">
  <span id="statusMode">Idle</span>
  <span>Gain: <span id="statusGain">--</span></span>
  <span>Gate: <span id="statusGate">--</span> dB</span>
</footer>
</body>
</html>
